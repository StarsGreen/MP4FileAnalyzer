

struct mp4boxtype_arr
{
"ftyp", "xx", "yy"
};

int nSize = strlen(fileName);
m_pFileName = new char[nSize + 1];








Box* pBox = Processer->createBox(type, mainStream);
//        Processer->addBox(pBox);
//

createBox(type, mainStream)
{
if (strcmp == ftype)
{
box = new FTYP_BOX();
box->skdjf
slkdfjsdlf;
lskdjfsdf;

}

return box;

}

boxlist;
std::list<Box*> pList;
pList->push(box);



char* boxItems[4] = {
"data",
"ftyp",
"moov"
}


void Processer::processData(Box* box , std::ifstream * mainStream, size_t length , FileManger * filemanger)
{

for (int i = 0; boxItems.size(); ++i)
{
strcmp(type, boxItmes[i] == 0)
{
sdlkfj;
break;
}
, <#std::ifstream *mainStream#>, <#size_t length#>, <#FileManger *filemanger#>
}

if(box->mParsingType == "data")
{
test(box , mainStream, length, filemanger);
}


};



//
if( strcmp( type, "ftyp" ) == 0 )
{

//box = (Box *)(new FTYP_BOX());
box = new FTYP_BOX();
//box = test;

std::cout << type << std::endl;
std::cout << dataLength << std::endl;

}



//int WriteFile(std::map<char * , std::string> *m) {
//    int count = 0;
//    if (m->empty())
//        return 0;
//
//    FILE *fp = fopen("out_put.txt", "w");
//    if (!fp)
//        return -errno;
//
//    for(std::map<char *, std::string>::iterator it = m->begin(); it != m->end(); it++) {
//        fprintf(fp, "%s=%s\n", it->first.c_str(), it->second.c_str());
//        count++;
//    }
//
//    fclose(fp);
//    return count;
//}




