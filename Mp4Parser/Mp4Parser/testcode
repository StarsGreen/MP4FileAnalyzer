int hexView() {  // 헥사 뷰어 함수의 본체
FILE *in;
size_t offset = 0; // 번지
char buf16[16];    // 헥사 값이 16바이트, 즉, 한줄씩 저장될 버퍼
size_t buf16Len;   // 한줄에 들어있는 헥사 값의 개수, 즉, 길이


if ((in  = fopen("test1.mp4", "rb")) == NULL)
return 1; // 비주얼C 2003에서의 파일 열기



// 파일을 16바이트씩, 끝까지 읽으며 루프 돌리기
while ( (buf16Len = fread(buf16, sizeof(char), sizeof(buf16), in)) != NULL ) {
printf("%08X:  ", offset); // Offset (번지) 출력

// 헥사 부분의 헥사 값 16개 출력 (8개씩 2부분으로)
for (int i = 0; i < (int) buf16Len; i++) {
if (i == 8) printf(" "); // 8개씩 분리
printf("%02X ", (unsigned char) buf16[i]); // 헥사 값 출력
}

// 한 줄이 16 바이트가 되지 않을 때, 헥사 부분과 문자 부분 사이에 공백들 삽입
for (int i = 0; i <= (16 - (int) buf16Len) * 3; i++)
printf(" ");
if (buf16Len < 9) printf(" "); // 한줄이 9바이트보다 적을 때는 한칸 더 삽입

// 문자 부분 출력
for (int i = 0; i < (int) buf16Len; i++) {
if (buf16[i] >= 0x20 && buf16[i] <= 0x7E) // 특수 문자 아니면 출력
printf("%c", buf16[i]);
else printf("."); // 특수문자, 그래픽문자 등은 마침표로 출력
}

offset += 16; // 번지 값을 16 증가
printf("\n"); // 줄바꿈
}


if (offset == 0) printf("%08X:  ", offset); // 0바이트 파일일 경우 처리
fclose(in); // 파일 닫기

return 0;
}

// for hexview





















// option code/






void setOption()
{
// temp comment for debuging later I have to make some module that can do option for program  .
char fileName[10];

//strcpy(fileName,argv[1]);



// just error manger

//    if(Option::option_num > argc)
//    {
//        utilManger->errorManger->showErrorMessage(1);
//        return 0;
//    }
}





//////////////////






















// 1. parser 로나눈다data랑
   2. 생성자 기본
   3. data시작앞으로
   4.


//factory pattern

mp4parser a : public parser
aviparser b : public parser

ParserFactory c(mp4);
Parser* p = c.createParser();
p->parse();

if (m_pFileName)
{
delete
}



struct mp4boxtype_arr
{
"ftyp", "xx", "yy"
};

int nSize = strlen(fileName);
m_pFileName = new char[nSize + 1];








//     atom = ( MP4::Atom * )( new MP4::ELST() );
//  box = ( FileBox * )( new FTYP_Box() );
// ( ( FileBox * )box )->processData( mainStream, dataLength );










Box* pBox = Processer->createBox(type, mainStream);
//        Processer->addBox(pBox);
//

createBox(type, mainStream)
{
if (strcmp == ftype)
{
box = new FTYP_BOX();
box->skdjf
slkdfjsdlf;
lskdjfsdf;

}

return box;

}

boxlist;
std::list<Box*> pList;
pList->push(box);



char* boxItems[4] = {
"data",
"ftyp",
"moov"
}


void Processer::processData(Box* box , std::ifstream * mainStream, size_t length , FileManger * filemanger)
{

for (int i = 0; boxItems.size(); ++i)
{
strcmp(type, boxItmes[i] == 0)
{
sdlkfj;
break;
}
, <#std::ifstream *mainStream#>, <#size_t length#>, <#FileManger *filemanger#>
}

if(box->mParsingType == "data")
{
test(box , mainStream, length, filemanger);
}


};



//
if( strcmp( type, "ftyp" ) == 0 )
{

//box = (Box *)(new FTYP_BOX());
box = new FTYP_BOX();
//box = test;

std::cout << type << std::endl;
std::cout << dataLength << std::endl;

}



//int WriteFile(std::map<char * , std::string> *m) {
//    int count = 0;
//    if (m->empty())
//        return 0;
//
//    FILE *fp = fopen("out_put.txt", "w");
//    if (!fp)
//        return -errno;
//
//    for(std::map<char *, std::string>::iterator it = m->begin(); it != m->end(); it++) {
//        fprintf(fp, "%s=%s\n", it->first.c_str(), it->second.c_str());
//        count++;
//    }
//
//    fclose(fp);
//    return count;
//}




